---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  cache = FALSE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# bmlogit

<!-- badges: start -->
<!-- badges: end -->

The goal of `bmlogit` is to estimate the multinominal logistic regression with
prediction constraints.

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("soichiroy/bmlogit")
```
## Implementation


```{r load_package, message=FALSE}
library(bmlogit)
library(emlogit)
library(synthArea)
library(tidyr)
library(stringr)
```

Let's use the synthArea but add another Census covariate -- urban/rural. We use the [citylab](https://github.com/theatlantic/citylab-data/blob/master/citylab-congress/citylab_cdi.csv) index to classify NC's 13 CDs into three categories

```{r}
## load data
data(cces_nc)
data(acs_nc)

urban_recode <- function(cd) {
  case_when(
    cd %in% c("NC-03", "NC-07", "NC-08", "NC-11") ~ "Rural",
    cd %in% c("NC-01", "NC-02", "NC-05", "NC-06", "NC-10", "NC-13") ~ "Rural-suburban", 
    cd %in% c("NC-04", "NC-09", "NC-12") ~ "Sparse-suburban"
  )
}
cces_nc$rural <- urban_recode(cces_nc$cd)
acs_nc$rural <- urban_recode(acs_nc$cd)

```


```{r example}
## population data
# target_Y <- acs_nc %>% count(educ, wt = N) %>% mutate(prop = n / sum(n)) %>% pull(prop)
target_Y <- c(0.462, 0.258, 0.184, 0.096)

pop_X <- model.matrix(~age + gender + rural, data = acs_nc %>% count(age, gender, rural, wt = N))[,-1]
count_N <- acs_nc %>% count(age, gender, rural, wt = N) %>% pull(n)

## survey data
Y <- model.matrix(~educ-1, data = cces_nc)
X <- model.matrix(~age + gender + rural, data = cces_nc)[,-1]

## fit
fit <- bmlogit(Y = Y, X = X, 
               target_Y = target_Y, 
               pop_X = pop_X, 
               count_X = count_N,
               control = list(tol_pred = 0.005))


## multinominal logit without constraints
fit_em <- emlogit(Y = Y, X = X)

```

There is a set multinomial coefficients for each level of the outcome (relative to baseline). Here there are six coefficients for each of those levels: 5 levels of age, 1 for gender, and 3 for rurality.

```{r coef-bmlogit-emlogit, dpi=450, fig.height=3.5, fig.width=7.5, echo = FALSE, warning = FALSE}

raw_educ <- colMeans(Y)
names(raw_educ) <- str_remove(names(raw_educ), "educ")

par(mfrow = c(1, 3), mar = c(4, 4, 2, 1), pty = 's')
for (i in 1:3) {
  plot(NA,  NA,
       xlab = "emlogit coef", ylab = "bmlogit coef",
       main = names(raw_educ)[i + 1],
       xlim = c(-2, 2),
       ylim = c(-2, 2),
       bty = "n", 
       type = "none")
  abline(0, 1, col = 'gray', lty = 2)  
  points(fit_em$coef[, i + 1], fit$coef[, i + 1],  pch = 16)
}
```

We can compare the resulting predicted values. Each prediction from the regression is made for each X covariate, and then summed with weights according to their known counts. 


```{r, echo = FALSE}
res <- cbind(target_Y,
  predict(fit, newdata = pop_X, counts = count_N),
  as.vector(crossprod(predict(fit_em, newdata = pop_X),  count_N / sum(count_N))),
  raw_educ
)

knitr::kable(res, col.names = c("Target", "bmlogit", "emlogit", "Raw"),
             digits = 3)
```

We clearly see that bmlogit is closer to the target population, and emlogit defaults to the raw data.

## Application to Post-Stratification and Estimatig Turnout

We now try to estimate turnout poststratifying on a synthetic distribution that was created by either emlogit, bmlogit, or simple weights.

The prediction for a third variable, `Y` (turnout in this case) should go like this:

```{r}
#' @param pop Population targets, with variables called `weight`
pred_turnout <- function(pop, microdata = cces_nc, XZ = c("educ", "age", "gender", "rural")) {
  
  XZw <- microdata %>% 
    group_by(!!!syms(XZ)) %>%
    summarise(turnout = sum(vv_turnout) / n(), .groups = "drop") %>%
    # join
    left_join(pop, by = XZ) %>%
    # rescale
    mutate(weight = weight / sum(weight))
  
  # inner product
  XZw$weight %*% XZw$turnout
}
```


We first do a simple weighted mean for the full joint (which we know in this case).

```{r}
# estimate state-wide quantity
data(districts_nc)
data(estimands_nc)

## turnout in NC
turnout <- sum(estimands_nc$totalvotes) / sum(estimands_nc$vap)

## raw estimate without adjustment
turnout_naive <- mean(cces_nc$vv_turnout)

## estimates stratified on educ, age, and gender
pop_tab <- acs_nc %>% 
  count(educ, age, gender, rural, wt = N) %>%
  mutate(weight = n / sum(n))

turnout_nonpar <- pred_turnout(pop_tab)
```

For bmlogit:

```{r}
popX_df <- acs_nc %>% 
  count(age, gender, rural, wt = N) %>% 
  transmute(age, gender, rural, prop_X = n / sum(n))

# compute the joint table
pr_joint <- predict(fit, newdata = pop_X)
colnames(pr_joint) <- c("HS or Less", "Some College", "4-Year", "Post-Grad")

pop_bmlogit <- bind_cols(popX_df, as_tibble(pr_joint)) %>%
  pivot_longer(cols = -c(age, gender, rural, prop_X),
               names_to = "educ", values_to = "pr") %>% 
  mutate(weight = prop_X * pr) # Pr(X) * Pr(Z | X)

turnout_bmlogit <- pred_turnout(pop_bmlogit)
```


For emlogit

```{r}
pr_joint <- predict(fit_em, newdata = pop_X)
colnames(pr_joint) <- c("HS or Less", "Some College", "4-Year", "Post-Grad")

pop_emlogit <- bind_cols(popX_df, as_tibble(pr_joint)) %>%
  pivot_longer(cols = -c(age, gender, rural, prop_X),
               names_to = "educ", values_to = "pr") %>% 
  mutate(weight = prop_X * pr) # Pr(X) * Pr(Z | X)

turnout_emlogit <- pred_turnout(pop_emlogit)
```

And we finally compare all four. The true statewide turnout is `r round(turnout, 3)`.

```{r, echo = FALSE}
est <- c(turnout_naive, turnout_nonpar,
         turnout_bmlogit, turnout_emlogit)
estimator  <- c("Sample Mean", "Post-str. w/ True Joint",
                "Post-str. w/ bmlogit Joint",
                "Post-str. w/ emlogit Joint")
knitr::kable(
  data.frame(estimator, est, est - turnout),
  col.names = c("Estimator", "Estimate", "Error"),
  digits = 3
)
```
